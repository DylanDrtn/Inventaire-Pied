<script type="module">
// ... (garde tout le reste inchang√©)

// üëâ remplace la d√©finition actuelle de loadStock() par celle-ci :
async function loadStock(){
  const { data, error } = await supabase.from('v_stock').select('*');
  if(error){ setMsg('err', "Lecture stock: " + error.message); return; }

  // 1) garder seulement les lignes avec stock > 0
  const nonZero = (data||[]).filter(r => (r.qty_current ?? 0) > 0);

  // 2) regrouper par (couleur, type) avec d√©duplication √©ventuelle
  const norm = s => (s||"").normalize('NFKC').toLowerCase().replace(/\s+/g,' ').trim();
  const title = s => (s||"").toLowerCase().replace(/\S+/g, w => w.charAt(0).toUpperCase()+w.slice(1));

  const grouped = new Map(); // key = norm(color)+'|'+type
  for(const r of nonZero){
    const key = norm(r.color) + '|' + (r.type || 'Grande table');
    const name = title(r.color);
    const type = r.type || 'Grande table';
    const qty = r.qty_current ?? 0;
    if(!grouped.has(key)) grouped.set(key, { name, type, qty: 0 });
    grouped.get(key).qty += qty;
  }

  // 3) rendu du tableau (seulement ce qui existe)
  const rows = [...grouped.values()]
    .sort((a,b)=> a.name.localeCompare(b.name) || a.type.localeCompare(b.type))
    .map(({name, type, qty})=>{
      return `<tr><td>${name}</td><td>${type}</td><td>${type === 'Petite table' ? '14x8 / 8x8' : '165x10 / 207x10'}</td><td>${qty}</td></tr>`;
    }).join('');

  document.getElementById('stockBody').innerHTML = rows || '<tr><td colspan="4">Aucune donn√©e</td></tr>';
  setMsg('ok', rows ? "Stock charg√©." : "Aucune ligne enregistr√©e.");
}
</script>